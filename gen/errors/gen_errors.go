//go:build ignore

package main

import (
	"fmt"
	"log"
	"os"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/goccy/go-yaml"
)

type Config map[string]struct {
	Prefix string `yaml:"prefix"`
	Errors []map[string]struct {
		Msg      string `yaml:"msg"`
		Severity string `yaml:"severity"`
	} `yaml:"errors"`
}

func main() {

	f := jen.NewFile("diag")
	f.HeaderComment("FILE GENERATED BY gen/gen_errors.go; DO NOT EDIT!")

	data, err := os.ReadFile("gen/errors/error_config.yaml")
	if err != nil {
		log.Fatal(err)
	}

	var cfg Config
	if err := yaml.Unmarshal(data, &cfg); err != nil {
		log.Fatal(err)
	}

	f.Line().Line()

	f.Comment("Type representing the error severity.")
	f.Type().Id("Severity").Int()

	f.Const().Defs(
		jen.Comment("Represents an error which must stop compilation."),
		jen.Id("Error").Id("Severity").Op("=").Iota(),

		jen.Comment("Represents an error that doesn't need to stop compilation, but triggers a diagnostic."),
		jen.Id("Warning"),
	)

	f.Comment("A type for containing compilation errors.")

	structType := "ErrorContainer"

	f.Type().Id(structType).Struct(
		jen.Id("Code").String().Comment("The error code."),
		jen.Id("Message").String().Comment("The error message."),
		jen.Id("Severity").Id("Severity").Comment("The severity of the error."),
		jen.Id("Context").Id("string").Comment("The file or context name where the error ocurred."),
		jen.Id("Line").Id("int").Comment("Where in the file did the error occur."),
	)

	f.Line().Line()

	f.Comment("Satisfying the error interface.")
	f.Func().
		Params(
			jen.Id("ec").Op("*").Id(structType),
		).
		Id("Error").
		Params().
		String().
		Block(
			jen.Return().Qual("fmt", "Sprintf").Call(
				jen.Lit("(%s:%d) (%s) %s: %s."),
				jen.Id("ec").Dot("Context"),
				jen.Id("ec").Dot("Line"),
				jen.Id("ec").Dot("Code"),
				jen.Id("ec").Dot("Severity"),
				jen.Id("ec").Dot("Message"),
			),
		)

	for section, s := range cfg {
		kindType := section + "ErrorKind"
		registryName := strings.ToLower(section) + "ErrorRegistry"

		f.Type().Id(kindType).Int().Line()

		dfs := make([]jen.Code, 0)

		for i, errDef := range s.Errors {
			for name := range errDef {
				fname := fmt.Sprintf("%s%s", s.Prefix, name)
				if i == 0 {
					dfs = append(dfs, jen.Id(fname).Id(kindType).Op("=").Iota().Commentf("Error message: %s", errDef[name].Msg))
				} else {
					dfs = append(dfs, jen.Id(fname).Commentf("Error message: %s", errDef[name].Msg))
				}
			}
		}

		f.Const().Defs(dfs...)

		f.Line().Line()

		// Registry map
		regValues := make(jen.Dict)

		for i, errDef := range s.Errors {
			for name, props := range errDef {
				fname := fmt.Sprintf("%s%s", s.Prefix, name)
				msg := strings.ReplaceAll(props.Msg, `"`, `\"`)

				val := jen.Values(jen.Dict{
					jen.Id("Severity"): jen.Id(props.Severity),
					jen.Id("Code"):     jen.Lit(fmt.Sprintf("%s%04d", s.Prefix, i+1)),
					jen.Id("Message"):  jen.Lit(msg),
				})

				regValues[jen.Id(fname)] = val
			}
		}

		f.Var().Id(registryName).Op("=").Map(jen.Id(kindType)).Op("*").Id(structType).Values(regValues)

		f.Line().Line()

		swblock := make([]jen.Code, 0)

		for _, errDef := range s.Errors {
			for k, _ := range errDef {
				fname := fmt.Sprintf("%s%s", s.Prefix, k)
				swblock = append(swblock, jen.Case(jen.Id(fname)))
				swblock = append(swblock, jen.Return(jen.Lit(fname)))
			}
		}

		f.Func().Params(
			jen.Id("a").Id(kindType),
		).Id("String").Params().String().Block(
			jen.Switch(jen.Id("a")).Block(
				swblock...,
			),
			jen.Return(jen.Lit("[?]")),
		)

		f.Line().Line()

		f.Func().Id(fmt.Sprintf("Get%s", kindType)).
			Params(
				jen.Id("kind").Id(kindType),
				jen.Id("context").String(),
				jen.Id("line").Int(),
			).
			Op("*").Id(structType).
			Block(
				jen.Id("e").Op(":=").Op("*").Id(registryName).Index(jen.Id("kind")),
				jen.Id("e").Dot("Context").Op("=").Id("context"),
				jen.Id("e").Dot("Line").Op("=").Id("line"),
				jen.Return(jen.Op("&").Id("e")),
			)
	}

	err = f.Save("internal/diag/errors.go")

	if err != nil {
		panic(err)
	}
}
