//go:build ignore

package main

import (
	"fmt"
	"log"
	"os"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/goccy/go-yaml"
)

type Config map[string]struct {
	Prefix string `yaml:"prefix"`
	Errors []map[string]struct {
		Msg      string `yaml:"msg"`
		Severity string `yaml:"severity"`
	} `yaml:"errors"`
}

func main() {
	structType := "ErrorContainer"
	f := jen.NewFile("diag")
	f.Comment("FILE GENERATED BY gen/gen_errors.go; DO NOT EDIT!")

	data, err := os.ReadFile("gen/error_config.yaml")
	if err != nil {
		log.Fatal(err)
	}

	var cfg Config
	if err := yaml.Unmarshal(data, &cfg); err != nil {
		log.Fatal(err)
	}

	f.Line().Line()

	f.Comment("Type representing the error severity.")
	f.Type().Id("Severity").Int()

	f.Const().Defs(
		jen.Comment("Represents an error which must stop compilation."),
		jen.Id("Error").Id("Severity").Op("=").Iota(),

		jen.Comment("Represents an error that doesn't need to stop compilation, but triggers a diagnostic."),
		jen.Id("Warning"),
	)

	f.Comment("A type for containing compilation errors.")
	f.Type().Id(structType).Struct(
		jen.Comment("The error code."),
		jen.Id("Code").String(),
		jen.Line(),

		jen.Comment("The error message."),
		jen.Id("Message").String(),
		jen.Line(),

		jen.Comment("The severity of the error."),
		jen.Id("Severity").Id("Severity"),
		jen.Line(),
	)

	f.Line().Line()

	for section, s := range cfg {
		kindType := section + "ErrorKind"
		registryName := section + "ErrorRegistry"

		f.Type().Id(kindType).Int().Line()

		dfs := make([]jen.Code, 0)

		for i, errDef := range s.Errors {
			for name := range errDef {
				fname := fmt.Sprintf("%s%s", s.Prefix, name)
				dfs = append(dfs, jen.Commentf("Error message: %s", errDef[name].Msg))
				if i == 0 {
					dfs = append(dfs, jen.Id(fname).Id(kindType).Op("=").Iota())
				} else {
					dfs = append(dfs, jen.Id(fname))
				}
				dfs = append(dfs, jen.Line())
			}
		}

		f.Const().Defs(dfs...)

		f.Line().Line()

		// Registry map
		regValues := make(jen.Dict)

		for i, errDef := range s.Errors {
			for name, props := range errDef {
				fname := fmt.Sprintf("%s%s", s.Prefix, name)
				msg := strings.ReplaceAll(props.Msg, `"`, `\"`)

				val := jen.Values(jen.Dict{
					jen.Id("Severity"): jen.Id(props.Severity),
					jen.Id("Code"):     jen.Lit(fmt.Sprintf("%s%04d", s.Prefix, i+1)),
					jen.Id("Message"):  jen.Lit(msg),
				})

				regValues[jen.Id(fname)] = val
			}
		}

		f.Var().Id(registryName).Op("=").Map(jen.Id(kindType)).Id(structType).Values(regValues)

		f.Line().Line()

		swblock := make([]jen.Code, 0)

		for _, errDef := range s.Errors {
			for k, _ := range errDef {
				fname := fmt.Sprintf("%s%s", s.Prefix, k)
				swblock = append(swblock, jen.Case(jen.Id(fname)))
				swblock = append(swblock, jen.Return(jen.Lit(fname)))
			}
		}

		f.Func().Params(
			jen.Id("a").Id(kindType),
		).Id("String").Params().String().Block(
			jen.Switch(jen.Id("a")).Block(
				swblock...,
			),
			jen.Return(jen.Lit("[?]")),
		)
	}

	err = f.Save("internal/diag/errors.go")

	if err != nil {
		panic(err)
	}
}
