// FILE GENERATED BY gen/gen_errors.go; DO NOT EDIT!

package diag

import "fmt"

// Type representing the error severity.
type Severity int

const (
	// Represents an error which must stop compilation.
	Error Severity = iota
	// Represents an error that doesn't need to stop compilation, but triggers a diagnostic.
	Warning
)

// A type for containing compilation errors.
type ErrorContainer struct {
	Code     string   // The error code.
	Message  string   // The error message.
	Severity Severity // The severity of the error.
	Context  string   // The file or context name where the error ocurred.
	Line     int      // Where in the file did the error occur.
}

// Satisfying the error interface.
func (ec *ErrorContainer) Error() string {
	return fmt.Sprintf("(%s:%d) (%s) %s: %s.", ec.Context, ec.Line, ec.Code, ec.Severity, ec.Message)
}

type LexerErrorKind int

const (
	LUnexpectedChar           LexerErrorKind = iota // Error message: Got an unexpected character
	LUnterminatedString                             // Error message: String literal is not terminated
	LUnterminatedBlockComment                       // Error message: Block comment was not terminated
	LInvalidNumberLiteral                           // Error message: Got invalid number literal
	LInvalidEscape                                  // Error message: Got invalid escape sequence
)

var lexerErrorRegistry = map[LexerErrorKind]*ErrorContainer{
	LInvalidEscape: {
		Code:     "L0005",
		Message:  "Got invalid escape sequence",
		Severity: Error,
	},
	LInvalidNumberLiteral: {
		Code:     "L0004",
		Message:  "Got invalid number literal",
		Severity: Error,
	},
	LUnexpectedChar: {
		Code:     "L0001",
		Message:  "Got an unexpected character",
		Severity: Error,
	},
	LUnterminatedBlockComment: {
		Code:     "L0003",
		Message:  "Block comment was not terminated",
		Severity: Error,
	},
	LUnterminatedString: {
		Code:     "L0002",
		Message:  "String literal is not terminated",
		Severity: Error,
	},
}

func (a LexerErrorKind) String() string {
	switch a {
	case LUnexpectedChar:
		return "LUnexpectedChar"
	case LUnterminatedString:
		return "LUnterminatedString"
	case LUnterminatedBlockComment:
		return "LUnterminatedBlockComment"
	case LInvalidNumberLiteral:
		return "LInvalidNumberLiteral"
	case LInvalidEscape:
		return "LInvalidEscape"
	}
	return "[?]"
}

func GetLexerErrorKind(kind LexerErrorKind, context string, line int) *ErrorContainer {
	e := *lexerErrorRegistry[kind]
	e.Context = context
	e.Line = line
	return &e
}

type ParserErrorKind int

const (
	PUnexpectedToken                ParserErrorKind = iota // Error message: Unexpected token.
	PExpectedIdentifier                                    // Error message: Expected identifier
	PExpectedParameterIdentifier                           // Error message: Expected parameter identifier
	PExpectedFunctionParenthesis                           // Error message: Expected '(' after function name
	PInvalidTypeExpression                                 // Error message: Invalid type expression
	PExpectedFunctionParamComma                            // Error message: Expected ',' after a non-terminal function parameter declaration
	PExpectedSemicolon                                     // Error message: Expected semicolon ';'
	PExpectedCloseBracketAfterBlock                        // Error message: Expected '}' after a block
	PInvalidExpressionToken                                // Error message: Got an unexpected token for expression
	PExpectedClosingParenthesis                            // Error message: Expected ')'
	PExpectedClosingSquare                                 // Error message: Expected ']'
	PExpectedComma                                         // Error message: Expected ','
)

var parserErrorRegistry = map[ParserErrorKind]*ErrorContainer{
	PExpectedCloseBracketAfterBlock: {
		Code:     "P0008",
		Message:  "Expected '}' after a block",
		Severity: Error,
	},
	PExpectedClosingParenthesis: {
		Code:     "P0010",
		Message:  "Expected ')'",
		Severity: Error,
	},
	PExpectedClosingSquare: {
		Code:     "P0011",
		Message:  "Expected ']'",
		Severity: Error,
	},
	PExpectedComma: {
		Code:     "P0012",
		Message:  "Expected ','",
		Severity: Error,
	},
	PExpectedFunctionParamComma: {
		Code:     "P0006",
		Message:  "Expected ',' after a non-terminal function parameter declaration",
		Severity: Error,
	},
	PExpectedFunctionParenthesis: {
		Code:     "P0004",
		Message:  "Expected '(' after function name",
		Severity: Error,
	},
	PExpectedIdentifier: {
		Code:     "P0002",
		Message:  "Expected identifier",
		Severity: Error,
	},
	PExpectedParameterIdentifier: {
		Code:     "P0003",
		Message:  "Expected parameter identifier",
		Severity: Error,
	},
	PExpectedSemicolon: {
		Code:     "P0007",
		Message:  "Expected semicolon ';'",
		Severity: Error,
	},
	PInvalidExpressionToken: {
		Code:     "P0009",
		Message:  "Got an unexpected token for expression",
		Severity: Error,
	},
	PInvalidTypeExpression: {
		Code:     "P0005",
		Message:  "Invalid type expression",
		Severity: Error,
	},
	PUnexpectedToken: {
		Code:     "P0001",
		Message:  "Unexpected token.",
		Severity: Error,
	},
}

func (a ParserErrorKind) String() string {
	switch a {
	case PUnexpectedToken:
		return "PUnexpectedToken"
	case PExpectedIdentifier:
		return "PExpectedIdentifier"
	case PExpectedParameterIdentifier:
		return "PExpectedParameterIdentifier"
	case PExpectedFunctionParenthesis:
		return "PExpectedFunctionParenthesis"
	case PInvalidTypeExpression:
		return "PInvalidTypeExpression"
	case PExpectedFunctionParamComma:
		return "PExpectedFunctionParamComma"
	case PExpectedSemicolon:
		return "PExpectedSemicolon"
	case PExpectedCloseBracketAfterBlock:
		return "PExpectedCloseBracketAfterBlock"
	case PInvalidExpressionToken:
		return "PInvalidExpressionToken"
	case PExpectedClosingParenthesis:
		return "PExpectedClosingParenthesis"
	case PExpectedClosingSquare:
		return "PExpectedClosingSquare"
	case PExpectedComma:
		return "PExpectedComma"
	}
	return "[?]"
}

func GetParserErrorKind(kind ParserErrorKind, context string, line int) *ErrorContainer {
	e := *parserErrorRegistry[kind]
	e.Context = context
	e.Line = line
	return &e
}
